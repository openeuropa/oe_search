<?php

declare(strict_types = 1);

namespace Drupal\oe_search\Plugin\search_api\backend;

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Plugin\PluginFormInterface;
use Drupal\Core\Render\RendererInterface;
use Drupal\Core\Site\Settings;
use Drupal\search_api\Backend\BackendPluginBase;
use Drupal\search_api\IndexInterface;
use Drupal\search_api\Plugin\PluginFormTrait;
use Drupal\search_api\Query\ConditionGroupInterface;
use Drupal\search_api\Query\QueryInterface;
use GuzzleHttp\ClientInterface as HttpClientInterface;
use Laminas\Diactoros\RequestFactory;
use Laminas\Diactoros\StreamFactory;
use OpenEuropa\EuropaSearchClient\Api\FacetApi;
use OpenEuropa\EuropaSearchClient\Api\IngestionApi;
use OpenEuropa\EuropaSearchClient\Api\SearchApi;
use OpenEuropa\EuropaSearchClient\Client;
use OpenEuropa\EuropaSearchClient\ClientInterface;
use OpenEuropa\EuropaSearchClient\Model\Document;
use Symfony\Component\DependencyInjection\Container;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * Europa Search backend for Search API.
 *
 * @SearchApiBackend(
 *   id = "search_api_europa_search",
 *   label = @Translation("Europa Search"),
 *   description = @Translation("Index items using Europa Search search server."),
 * )
 */
class SearchApiEuropaSearchBackend extends BackendPluginBase implements PluginFormInterface {

  use PluginFormTrait {
    submitConfigurationForm as traitSubmitConfigurationForm;
  }

  /**
   * Connection info stored as Drupal settings.
   *
   * These connection information are sensitive data and may be different on
   * each environment (i.e. the acceptance machine may use an Europa Search
   * sandbox instance). For this reason we'll store them as settings in
   * `settings.php` file rather than config storage. Storing them in config
   * would be a security concern, as configuration may end up being committed in
   * VCS and exposed publicly.
   *
   * @var string[]
   */
  const CONNECTION_SETTINGS = [
    'consumer_key',
    'consumer_secret',
  ];

  /**
   * The HTTP client.
   *
   * @var \GuzzleHttp\ClientInterface
   */
  protected $httpClient;

  /**
   * The site settings.
   *
   * @var \Drupal\Core\Site\Settings
   */
  protected $settings;

  /**
   * The renderer service.
   *
   * @var \Drupal\Core\Render\RendererInterface
   */
  protected $renderer;

  /**
   * The Europa Search client instance.
   *
   * @var \OpenEuropa\EuropaSearchClient\ClientInterface
   */
  protected $client;

  /**
   * Constructs a new plugin instance.
   *
   * @param array $configuration
   *   A configuration array containing information about the plugin instance.
   * @param string $plugin_id
   *   The plugin_id for the plugin instance.
   * @param array $plugin_definition
   *   The plugin implementation definition.
   * @param \GuzzleHttp\ClientInterface $http_client
   *   The HTTP client.
   * @param \Drupal\Core\Site\Settings $settings
   *   The site settings.
   * @param \Drupal\Core\Render\RendererInterface $renderer
   *   The renderer service.
   */
  public function __construct(array $configuration, $plugin_id, array $plugin_definition, HttpClientInterface $http_client, Settings $settings, RendererInterface $renderer) {
    parent::__construct($configuration, $plugin_id, $plugin_definition);
    $this->httpClient = $http_client;
    $this->settings = $settings;
    $this->renderer = $renderer;
  }

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    return new static(
      $configuration,
      $plugin_id,
      $plugin_definition,
      $container->get('http_client'),
      $container->get('settings'),
      $container->get('renderer')
    );
  }

  /**
   * {@inheritdoc}
   */
  public function defaultConfiguration(): array {
    return [
      'api_key' => NULL,
      'database' => NULL,
      'ingestion_api_endpoint' => NULL,
      'search_api_endpoint' => NULL,
      'token_api_endpoint' => NULL,
    ] + parent::defaultConfiguration();
  }

  /**
   * {@inheritdoc}
   */
  public function isAvailable(): bool {
    // Check that all settings from settings.php are set.
    // @todo Perform also a ping as soon as the functionality is available.
    return array_keys(array_filter($this->getConnectionSettings())) === static::CONNECTION_SETTINGS;
  }

  /**
   * {@inheritdoc}
   */
  public function buildConfigurationForm(array $form, FormStateInterface $form_state): array {
    $this->checkMissingSettings();

    $configuration = $this->getConfiguration();

    $form['api_key'] = [
      '#type' => 'textfield',
      '#title' => $this->t('API key'),
      '#description' => $this->t('The API key is a unique key generated by the search team. It ties your application to a specific behaviour (allowed field names, security details, display templates, field translations, etc).'),
      '#required' => TRUE,
      '#default_value' => $configuration['api_key'],
    ];

    $form['database'] = [
      '#type' => 'textfield',
      '#title' => $this->t('Database'),
      '#description' => $this->t('The database element correspond to a dataSource that contains the documents.'),
      '#required' => TRUE,
      '#default_value' => $configuration['database'],
    ];

    $form['ingestion_api_endpoint'] = [
      '#type' => 'url',
      '#title' => $this->t('Ingestion API endpoint'),
      '#description' => $this->t('The URL of the endpoint where the Ingestion API is available.'),
      '#required' => TRUE,
      '#default_value' => $configuration['ingestion_api_endpoint'],
    ];

    $form['search_api_endpoint'] = [
      '#type' => 'url',
      '#title' => $this->t('Search API endpoint'),
      '#description' => $this->t('The URL of the endpoint where the Search API is available.'),
      '#required' => TRUE,
      '#default_value' => $configuration['search_api_endpoint'],
    ];

    $form['token_api_endpoint'] = [
      '#type' => 'url',
      '#title' => $this->t('Token API endpoint'),
      '#description' => $this->t('The URL of the endpoint where the Token API is available.'),
      '#required' => TRUE,
      '#default_value' => $configuration['token_api_endpoint'],
    ];

    return $form;
  }

  /**
   * {@inheritdoc}
   */
  public function viewSettings() {
    $configuration = $this->getConfiguration() + $this->getConnectionSettings();

    $info[] = [
      'label' => $this->t('API key'),
      'info' => $configuration['api_key'],
    ];

    $info[] = [
      'label' => $this->t('Database'),
      'info' => $configuration['database'],
    ];

    $info[] = [
      'label' => $this->t('Ingestion API endpoint'),
      'info' => $configuration['ingestion_api_endpoint'],
    ];

    $info[] = [
      'label' => $this->t('Search API endpoint'),
      'info' => $configuration['search_api_endpoint'],
    ];

    $info[] = [
      'label' => $this->t('Token API endpoint'),
      'info' => $configuration['token_api_endpoint'],
    ];

    $info[] = [
      'label' => $this->t('Consumer key'),
      'info' => $configuration['consumer_key'],
    ];

    $info[] = [
      'label' => $this->t('Consumer secret'),
      'info' => $configuration['consumer_secret'],
    ];

    return $info;
  }

  /**
   * {@inheritdoc}
   */
  public function getSupportedFeatures() {
    return [
      'search_api_facets',
      'search_api_facets_operator_or',
    ];
  }

  /**
   * {@inheritdoc}
   */
  public function indexItems(IndexInterface $index, array $items): array {
    $api = new IngestionApi($this->getClient());

    // @todo Support multiple indexes #OEL-149.
    $indexed = [];
    /** @var \Drupal\search_api\Item\ItemInterface[] $items */
    foreach ($items as $id => $item) {
      try {
        $ingestion = $api->ingestText([
          'uri' => $item->getOriginalObject()->getValue()->toUrl()->setAbsolute()->toString(),
          'text' => $item->getOriginalObject()->getValue()->label(),
          'reference' => $id,
        ]);
        $indexed[] = $ingestion->getReference();
      }
      catch (\Exception $e) {
        $this->getLogger()->warning($e->getMessage());
      }
    }

    return $indexed;
  }

  /**
   * {@inheritdoc}
   */
  public function deleteItems(IndexInterface $index, array $item_ids): void {
    $api = new IngestionApi($this->getClient());

    foreach ($item_ids as $item_id) {
      try {
        $api->deleteDocument($item_id);
      }
      catch (\Exception $e) {
        $this->getLogger()->warning($e->getMessage());
      }
    }
  }

  /**
   * {@inheritdoc}
   */
  public function deleteAllIndexItems(IndexInterface $index, $datasource_id = NULL): void {
    // There is no method to bulk delete items in the Europa Search API.
    // Fetch all the documents available and then delete them one by one.
    $api = new SearchApi($this->getClient());
    $search = $api->search();

    $item_ids = array_map(function (Document $document) {
      return $document->getReference();
    }, $search->getResults());

    // @todo Handle datasource.
    $this->deleteItems($index, $item_ids);
  }

  /**
   * {@inheritdoc}
   */
  public function search(QueryInterface $query): void {
    // @todo Make sure the search is run using the proper index.
    $api = new SearchApi($this->getClient());
    $apiFacet = new FacetApi($this->getClient());
    $facet = $apiFacet->query();
    $search = $api->search();
    $options = $query->getOptions();

    $result_set = $query->getResults();
    $result_set->setResultCount($search->getTotalResults());

    foreach ($search->getResults() as $document) {
      $result_item = $this->fieldsHelper->createItem($query->getIndex(), $document->getReference());
      $result_set->addResultItem($result_item);
    }

    $facets = isset($options['search_api_facets'])
      ? array_column($options['search_api_facets'], 'field')
      : [];

    $es_options = [
      'attributesToRetrieve' => [
        'search_api_id',
      ],
      'facets' => $facets,
      'analytics' => TRUE,
    ];

    if (!empty($options['limit'])) {
      $es_options['length'] = $options['limit'];
      $es_options['offset'] = $options['offset'];
    }

    $this->extractConditions($query->getConditionGroup(), $es_options, $facets);

    if ($facet->getFacets() !== NULL) {
      $result_set->setExtraData(
        'search_api_facets',
        $this->extractFacetsData($facets, $facet->getFacets())
      );
    }

    \Drupal::messenger()->addWarning($this->t('Search is not fully supported yet in %backend backends.', [
      '%backend' => $this->label(),
    ]));
  }

  /**
   * Extract facets data from response.
   *
   * @param array $facets
   *   Facets to extract.
   * @param array $data
   *   Facets data from response.
   *
   * @return array
   *   Facets data in format required by Drupal.
   */
  private function extractFacetsData(array $facets, array $data): array {
    $facets_data = [];

    foreach ($data as $facet_data) {
      if (!in_array($facet_data->rawName, $facets)) {
        continue;
      }
      $facets_data[$facet_data->rawName][] = [
        'count' => $facet_data->count,
        'filter' => '"' . $facet_data->rawName . '"',
      ];
    }

    return $facets_data;
  }

  /**
   * Extract conditions.
   *
   * @param \Drupal\search_api\Query\ConditionGroupInterface $condition_group
   *   Condition group.
   * @param array $options
   *   Europa Search options.
   * @param array $facets
   *   Facets.
   */
  private function extractConditions(ConditionGroupInterface $condition_group, array &$options, array $facets) {
    foreach ($condition_group->getConditions() as $condition) {
      if ($condition instanceof ConditionGroupInterface) {
        $this->extractConditions($condition, $options, $facets);
        continue;
      }

      $field = $condition->getField();

      /** @var \Drupal\search_api\Query\Condition $condition */
      // We support limited operators for now.
      if ($condition->getOperator() == '=') {
        $query = $field . ':' . $condition->getValue();

        if (in_array($field, $facets)) {
          $options['facetFilters'][$field][] = $query;
          $options['disjunctiveFacets'][$field] = $field;
        }
        else {
          $options['filters'] = isset($options['filters'])
            ? ' AND ' . $query
            : $query;
        }
      }
      elseif (in_array($condition->getOperator(), ['<', '>', '<=', '>='])) {
        $options['numericFilters'][] = $field . ' ' . $condition->getOperator() . ' ' . $condition->getValue();
      }
    }
  }

  /**
   * Returns an Europa Search client instance.
   *
   * @return \OpenEuropa\EuropaSearchClient\ClientInterface
   *   The client.
   */
  protected function getClient(): ClientInterface {
    if (!isset($this->client)) {
      // Merge configuration and settings together.
      $configuration = $this->getConfiguration() + $this->getConnectionSettings();
      // The client uses the camelized version of connection data identifiers.
      $configuration = array_map(Container::class . '::camelize', $configuration);
      // @todo Refactor this instantiation to a new plugin type in OEL-152.
      // @see https://citnet.tech.ec.europa.eu/CITnet/jira/browse/OEL-152
      $this->client = new Client($this->httpClient, new RequestFactory(), new StreamFactory(), $configuration);
    }
    return $this->client;
  }

  /**
   * Returns the values of connection settings.
   *
   * These connection data is considered sensitive and depending on the
   * environment, thus is stored in `settings.php`, rather than config store.
   *
   * @return array
   *   The values of connection settings.
   */
  protected function getConnectionSettings(): array {
    return array_map(function (string $setting): ?string {
      return $this->settings->get('oe_search')['backend'][$this->getServer()->id()][$setting] ?? NULL;
    }, array_combine(static::CONNECTION_SETTINGS, static::CONNECTION_SETTINGS));
  }

  /**
   * Issues a warning messages if some settings are missing from settings.php.
   */
  protected function checkMissingSettings(): void {
    $missing_settings = [];
    $consumer_settings_template = "\$settings['oe_search']['backend']['%s']['%s'] = '%s';";
    foreach ($this->getConnectionSettings() as $setting => $value) {
      if (!$value) {
        $missing_settings[] = sprintf($consumer_settings_template, $this->getServer()->id(), $setting, $this->t('@name value...', [
          '@name' => str_replace('_', ' ', $setting),
        ]));
      }
    }

    if (!$missing_settings) {
      return;
    }

    $error = [
      [
        '#markup' => $this->t('Missing <code>settings.php</code> entries:'),
      ],
      [
        '#type' => 'html_tag',
        '#tag' => 'pre',
        '#value' => implode("\n", $missing_settings),
      ],
    ];
    $this->messenger()->addError($this->renderer->render($error));
  }

}

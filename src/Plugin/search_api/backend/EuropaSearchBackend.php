<?php

declare(strict_types = 1);

namespace Drupal\oe_search\Plugin\search_api\backend;

use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Language\LanguageInterface;
use Drupal\Core\Plugin\PluginFormInterface;
use Drupal\Core\StringTranslation\StringTranslationTrait;
use Drupal\search_api\Backend\BackendPluginBase;
use Drupal\search_api\IndexInterface;
use Drupal\search_api\Query\QueryInterface;
use OpenEuropa\EuropaSearchClient\Model\Document;
use Solarium\QueryType\Select\Query\Query;
use Symfony\Component\DependencyInjection\ContainerInterface;

/**
 * European Commission Europa Search backend for search_api.
 *
 * @SearchApiBackend(
 *   id = "oe_search",
 *   label = @Translation("EC Europa Search"),
 *   description = @Translation("Index items using EC Europa Search backend.")
 * )
 */
class EuropaSearchBackend extends BackendPluginBase implements PluginFormInterface {

  use StringTranslationTrait;

  /**
   * The config factory.
   *
   * @var \Drupal\Core\Config\ConfigFactoryInterface
   */
  protected $config;

  /**
   * The UserPlaces Helper custom module.
   *
   * @var \Drupal\oe_search\EuropaSearchService
   */
  protected $client;

  /**
   * {@inheritdoc}
   */
  public static function create(ContainerInterface $container, array $configuration, $plugin_id, $plugin_definition) {
    $instance = parent::create($container, $configuration, $plugin_id, $plugin_definition);
    $instance->client = $container->get('oe_search.es_service');
    $instance->config = $container->get('config.factory')->getEditable('oe_search.server');
    return $instance;
  }

  /**
   * {@inheritDoc}
   */
  public function buildConfigurationForm(array $form, FormStateInterface $form_state) {

    $form['api_key'] = [
      '#type' => 'textfield',
      '#title' => $this->t('API key'),
      '#description' => $this->t('The api key is a unique key generated by the search team. It ties your application to a specific behaviour (allowed field names, security details, display templates, field translations, etc).'),
      '#required' => TRUE,
      '#default_value' => $this->config->get('api_key'),
    ];

    $form['database'] = [
      '#type' => 'textfield',
      '#title' => $this->t('Database'),
      '#description' => $this->t('The database element correspond to a dataSource that contains the documents.'),
      '#required' => TRUE,
      '#default_value' => $this->config->get('database'),
    ];

    $form['ingestion_api_endpoint'] = [
      '#type' => 'url',
      '#title' => $this->t('Ingestion API endpoint'),
      '#description' => $this->t('The URL of the endpoint where the Ingestion API is available.'),
      '#required' => TRUE,
      '#default_value' => $this->config->get('ingestion_api_endpoint'),
    ];

    $form['search_api_endpoint'] = [
      '#type' => 'url',
      '#title' => $this->t('Search API endpoint'),
      '#description' => $this->t('The URL of the endpoint where the Search API is available.'),
      '#required' => TRUE,
      '#default_value' => $this->config->get('search_api_endpoint'),
    ];

    return $form;
  }

  /**
   * Form validation handler.
   */
  public function validateConfigurationForm(array &$form, FormStateInterface $form_state) {
  }

  /**
   * Form submission handler.
   */
  public function submitConfigurationForm(array &$form, FormStateInterface $form_state) {
    $this->config
      ->set('api_key', $form_state->getValue('api_key'))
      ->set('database', $form_state->getValue('database'))
      ->set('ingestion_api_endpoint', $form_state->getValue('ingestion_api_endpoint'))
      ->set('search_api_endpoint', $form_state->getValue('search_api_endpoint'))
      ->save();
  }

  /**
   * {@inheritdoc}
   */
  public function viewSettings() {
    $info[] = [
      'label' => $this->t('API key'),
      'info' => $this->config->get('api_key'),
    ];

    $info[] = [
      'label' => $this->t('Database'),
      'info' => $this->config->get('database'),
    ];

    $info[] = [
      'label' => $this->t('Ingestion API endpoint'),
      'info' => $this->config->get('ingestion_api_endpoint'),
    ];

    $info[] = [
      'label' => $this->t('Search API endpoint'),
      'info' => $this->config->get('search_api_endpoint'),
    ];

    return $info;
  }

  /**
   * {@inheritdoc}
   */
  public function getSupportedFeatures() {
    return [
      'search_api_facets',
      'search_api_facets_operator_or',
    ];
  }

  /**
   * {@inheritDoc}
   */
  public function indexItems(IndexInterface $index, array $items) {
    $api = $this->client->ingestionApi();

    // @todo Support multiple indexes by generating a reference id that takes
    //   into account index id and item id. Store the item id as separate
    //   field.
    $indexed = [];
    /** @var \Drupal\search_api\Item\ItemInterface[] $items */
    foreach ($items as $id => $item) {
      try {
        $ingestion = $api->ingestText([
          'uri' => $item->getOriginalObject()->getValue()->toUrl()->setAbsolute()->toString(),
          'text' => $item->getOriginalObject()->getValue()->label(),
          'reference' => $id,
        ]);
        $indexed[] = $ingestion->getReference();
      }
      catch (\Exception $e) {
        $this->getLogger()->warning($e->getMessage());
      }
    }

    return $indexed;
  }

  /**
   * {@inheritDoc}
   */
  public function deleteItems(IndexInterface $index, array $item_ids) {
    $api = $this->client->ingestionApi();

    foreach ($item_ids as $item_id) {
      try {
        $api->deleteDocument($item_id);
      }
      catch (\Exception $e) {
        $this->getLogger()->warning($e->getMessage());
      }
    }
  }

  /**
   * {@inheritDoc}
   */
  public function deleteAllIndexItems(IndexInterface $index, $datasource_id = NULL) {
    // There is no method to bulk delete items in the Europa Search API.
    // Fetch all the documents available and then delete them one by one.
    $results = $this->client->searchApi();

    $item_ids = array_map(function (Document $document) {
      return $document->getReference();
    }, $results);

    // @todo Handle datasource.
    $this->deleteItems($index, $item_ids);
  }

  /**
   * {@inheritDoc}
   */
  public function search(QueryInterface $query) {
    // @todo Make sure the search is run using the proper index.
    $results = $this->client->searchApi();

    $result_set = $query->getResults();
    $result_set->setResultCount($results);

    foreach ($results as $document) {
      $result_item = $this->fieldsHelper->createItem($query->getIndex(), $document->getReference());
      $result_set->addResultItem($result_item);
    }

    // @todo Implement FacetAPI from europa-search-client #OEL-97.
    $this->setFacets($query, $result_set);

    \Drupal::messenger()->addWarning($this->t('Search is not fully supported yet in %backend backends.', [
      '%backend' => $this->label(),
    ]));
  }

  /**
   * {@inheritDoc}
   */
  protected function setFacets(QueryInterface $query, Query $result_set) {
    // @todo Implement FacetAPI from europa-search-client #OEL-97.
    static $index_fulltext_fields = [];

    $facets = $query->getOption('search_api_facets', []);
    if (empty($facets)) {
      return;
    }

    $index = $query->getIndex();
    $index_id = $index->id();

    $field_names = $this->getLanguageSpecificSolrFieldNames(LanguageInterface::LANGCODE_NOT_SPECIFIED, $index);

    $facet_set = $result_set->getFacetSet();
    $facet_set->setSort('count');
    $facet_set->setLimit(10);
    $facet_set->setMinCount(1);
    $facet_set->setMissing(FALSE);

    foreach ($facets as $info) {
      if (empty($field_names[$info['field']])) {
        continue;
      }
      $esc_field = $field_names[$info['field']];

      // Backward compatibility for facets.
      $info += ['query_type' => 'search_api_string'];

      $this->setFacetField($esc_field, $index, $index_id, $info, $facet_set);
    }
  }

  /**
   * {@inheritDoc}
   */
  protected function setFacetField($esc_field, $index, $index_id, $info, $facet_set, $facet_field = NULL) {
    if (!isset($index_fulltext_fields[$index_id])) {
      $index_fulltext_fields[$index_id] = $index->getFulltextFields();
    }

    if (in_array($info['field'], $index_fulltext_fields[$index_id])) {
      \Drupal::messenger()->addWarning($this->t('Facetting on fulltext fields is not yet supported. Consider to add a string field to the index for that purpose.', [
        '%backend' => $this->label(),
      ]));
    }
    else {
      // Create the Europa Search Client facet field object.
      $facet_field = $facet_set->createFacetField($esc_field)->setField($esc_field);
    }

    // Set limit, unless it's the default.
    if ($info['limit'] != 10) {
      $limit = $info['limit'] ? $info['limit'] : -1;
      $facet_field->setLimit($limit);
    }
    // Set missing.
    $facet_field->setMissing(isset($info['missing']));

    // For "OR" facets, add the expected tag for exclusion.
    if (isset($info['operator']) && strtolower($info['operator']) === 'or') {
      // The tag "facet:field_name" is defined by the facets module. Therefore
      // we have to use the Search API field name here to create the same tag.
      // @see \Drupal\facets\QueryType\QueryTypeRangeBase::execute()
      // @see https://cwiki.apache.org/confluence/display/solr/Faceting#Faceting-LocalParametersforFaceting
      $facet_field->setExcludes(['facet:' . $info['field']]);
    }

    // Set mincount, unless it's the default.
    if ($info['min_count'] != 1) {
      $facet_field->setMinCount($info['min_count']);
    }
  }

}
